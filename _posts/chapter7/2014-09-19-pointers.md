---
title: Pointers and Arrays
categories: notes
layout: post
chapter: 7
tags:
    - identity 
    - nullptr 
    - raw string
    - array
    - const
    - constexpr
    - resource
---

* it is said that an object has an *identity* if it has its address in memory
  and type

* pointers and references are language constructs for holding and using address

* any pointer can be cast to `void*` except a pointer to function and member

* `nullptr` is preferred to `0` because the latter has a type of `int`
  (consider an overloaded function `f(...)` that accepts either a pointer or
  `int`: which version should be called at `f(0)`?)

* `NULL` macro is implementation defined, e.g. `0`, `0L`, or even something else

* array number of elements should be `constexpr`

* array may be initialized with `initializer_list` if smaller size than the size
  of array, e.g.:

```
int* values[5] {1, 2, 3};  // missing values will be initialized to int {}
```

* string literals are always of type `const char*` and have terminating `\0`
  symbol

* string literals are **statically** allocated, e.g. it is safe to return one
  from a function

* the same string literals can be allocated at different addresses, e.g. it is
  an implementation-defined:

```
const char* a {"Hello"};
const char* b {"Hello"};
bool equal {a == b};  // implementation-defined
```

* string literal can be split, e.g.:

```
const char* longName {"Hello"
                      " World!"}; 
```

* Raw string has the following syntax `R"(...)"` or `R"#(...)#"` where `#` is
  any sequence of characters, e.g. `R"raw(...)raw"`

* Raw string may contain a new line, e.g.:

```
const char* welcome {R"(Welcome!

We are glad to have you here today.
Enjoy your day!)"};
```

* taking a pointer to the element one beyond the end of an array is guaranteed
  to work but can not be used for read or write operation

* access elements outside of range `[0,N]` is undefined

* subtraction of pointers is only defined if two pointers belong to the same
  array and operator returns distance between two pointers, e.g.:

```
int* values[] {1, 2, 3, 4, 5};
int* p {values + 3};
int* q {values + 1};
int distance {p - q};  // get distance in range [p,q)
```

* arrays can not be copied and as such can not be passed by value, e.g.:

```
// Two equivalent declarations
void Process1(int arg[10]);  // arg is an int*: array bound is ignored (!)
void Process2(int* arg);
```

* passing 2D array has a trap: `m[i][j]` inside a function that takes the array
  would mean `*(*(m + i) + j)`

* `const`'s primary role i to specify immutability in interfaces, e.g.
  immutability after initialization

* `constexpr` is to enable and ensure compile-time evaluation

* there is no way to assign to constant object and therefore it has to be
  initialized right away, e.g. declaration with definition.

* `const` modified a type: it restricts the way in which an object can be used,
  rather than specifying how the constant is allocated

* when pointer is used there are two objects involved: pointer itself and object
  pointed at; therefore `const T...` makes the object constant, while `*const`
  makes the pointer constant, e.g.:

```
int* p;  // pointer to int
const int* q;  // pointer to const int
int* const r;  // const pointer to int
const int* const z;  // const pointer to const int
```

* it is possible to restrict the interface form non-const to const but not vise
  versa, e.g.:

```
int a;
const int b;
const int* p {&a};
const int* q {&b};
int* x {&a};
int* y {&b};  // error: initialize int* with const int*
```

* a *resourse* is something that has to be acquired and later released
